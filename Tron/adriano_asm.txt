;===============================================================================
; Program Information
;===============================================================================

    ; Program:      Collect
    ; Program by:   Darrell Spice, Jr
    ; Last Update:  June 25, 2014
    ;
    ; Super simple game of "collect the boxes" used for presentation on
    ; developing Atari 2600 homebrew games.
    ;
    ; See readme.txt for compile instructions
    
    
;===============================================================================
; Change Log
;===============================================================================
 
    ; 2013.06.24 - generate a stable display
    ; 2013.06.25 - add timers 


;===============================================================================
; Initialize dasm
;===============================================================================

    ; Dasm supports a number of processors, this line tells dasm the code
    ; is for the 6502 CPU.  The Atari has a 6507, which is 6502 that's been
    ; put into a "reduced package".  This package limits the 6507 to an 8K
    ; address space and also removes support for external interrupts.
        PROCESSOR 6502
    
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

    
;===============================================================================
; Define RAM Usage
;===============================================================================

    ; define a segment for variables
    ; .U means uninitialized, does not end up in ROM
        SEG.U VARS
    
    ; RAM starts at $80
        ORG $80             

    ; coming soon!


;===============================================================================
; Define Start of Cartridge
;===============================================================================

    ; define a segment for code
    SEG CODE    
    
    ; 2K ROM starts at $F800, 4K ROM starts at $F000
    ORG $F800


;===============================================================================
; Initialize Atari
;===============================================================================
    
InitSystem:
    ; CLEAN_START is a macro found in macro.h
    ; it sets all RAM, TIA registers and CPU registers to 0
        CLEAN_START   

        
;===============================================================================
; Main Program Loop
;===============================================================================

Main:
        jsr VerticalSync    ; Jump to SubRoutine VerticalSync
        jsr VerticalBlank   ; Jump to SubRoutine VerticalBlank
        jsr Kernel          ; Jump to SubRoutine Kernel
        jsr OverScan        ; Jump to SubRoutine OverScan
        jmp Main            ; JuMP to Main
    

;===============================================================================
; Vertical Sync
; -------------
; here we generate the signal that tells the TV to move the beam to the top of
; the screen so we can start the next frame of video.
; The Sync Signal must be on for 3 scanlines.
;===============================================================================

VerticalSync:
        lda #2      ; LoaD Accumulator with 2 so D1=1
        ldx #49     ; LoaD X with 49
        sta WSYNC   ; Wait for SYNC (halts CPU until end of scanline)
        sta VSYNC   ; Accumulator D1=1, turns on Vertical Sync signal
        stx TIM64T  ; set timer to go off in 41 scanlines (49 * 64) / 76
        sta WSYNC   ; Wait for Sync - halts CPU until end of 1st scanline of VSYNC
        sta WSYNC   ; wait until end of 2nd scanline of VSYNC
        lda #0      ; LoaD Accumulator with 0 so D1=0
        sta WSYNC   ; wait until end of 3rd scanline of VSYNC
        sta VSYNC   ; Accumulator D1=0, turns off Vertical Sync signal
        rts         ; ReTurn from Subroutine
    
    
;===============================================================================
; Vertical Blank
; --------------
; game logic runs here.  Coming soon!
;===============================================================================

VerticalBlank:    
        rts             ; ReTurn from Subroutine

    
;===============================================================================
; Kernel
; ------
; here we update the registers in TIA (the video chip) in order to generate
; what the player sees.  For now we're just going to output 192 colored
; scanlines lines so we have something to see.
;===============================================================================

Kernel:            
        sta WSYNC       ; Wait for SYNC (halts CPU until end of scanline)
        lda INTIM       ; check the timer
        bne Kernel      ; Branch if its Not Equal to 0
    	; turn on the display
        sta VBLANK      ; Accumulator D1=0, turns off Vertical Blank signal (image output on)
        
	; Set up timer (in case of bugs where we don't hit exactly)
	TIMER_SETUP 192
    	SLEEP 10 ; to make timing analysis work out
        
       
        ;from the beging over and over
        sta WSYNC
        ldy #0

      	lda LineHeight,y
        tax
        
        lda ColorBackGround,y
        sta COLUBK
        
	lda ColorForeGround,y
        sta COLUPF
                       
RowsHeightLoop

	sta WSYNC        
        lda ColorBackGround,y
        sta COLUBK
                        
PatternChanged

        lda PF0_left,y 
        sta PF0 ; PF0 
        
        lda PF1_left,y 
        sta PF1 ; PF0    
        
        lda PF2_left,y 
        sta PF2 ; PF0
               
	SLEEP 2
        
        lda PF0_right,y
        sta PF0 ; PF0 
        
        lda PF1_right,y
        sta PF1 ; PF0    
        
        lda PF2_right,y
        sta PF2 ; PF0        

	
        
        dex
        bne RowsHeightLoop  ; Branch if Not Equal to 0    
	sleep 12	; == nop X 6
        
	;lda #0
       	;sta PF0
        ;sta PF1
        ;sta PF2		; clear playfield
        
        iny	;next pattern index
       
	lda ColorForeGround,y
        sta COLUPF        
	
      	lda LineHeight,y
        
        tax
        beq RowsEnd
        ;sta WSYNC
        ;lda LineHeight,y
        jmp PatternChanged;RowsHeightLoop; == 0, we're done
        
RowsEnd        
	sta WSYNC

	lda #0
        sta PF0
        sta PF1
        sta PF2		; clear playfield
        sta COLUBK
        sta COLUPF  

; Wait for timer to finish
	TIMER_WAIT
        rts             ; ReTurn from Subroutine

        
;===============================================================================
; Overscan
; --------------
; game logic runs here.  Since we don't have any yet, just delay so that the
; entire video frame consists of 262 scanlines
;===============================================================================

OverScan:
        sta WSYNC   ; Wait for SYNC (halts CPU until end of scanline)
        lda #2      ; LoaD Accumulator with 2 so D1=1
        sta VBLANK  ; STore Accumulator to VBLANK, D1=1 turns image output off
        
    ; set the timer for 27 scanlines.  Each scanline lasts 76 cycles,
    ; but the timer counts down once every 64 cycles, so use this
    ; formula to figure out the value to set.  
    ;       (scanlines * 76) / 64    
    ; Also note that it might be slight off due to when on the scanline TIM64T
    ; is updated.  So use Stella to check how many scanlines the code is
    ; generating and adjust accordingly.
        lda #32     ; set timer for 27 scanlines, 32 = ((27 * 76) / 64)
        sta TIM64T  ; set timer to go off in 27 scanlines
        
    ; game logic will go here
    
OSwait:
        sta WSYNC   ; Wait for SYNC (halts CPU until end of scanline)
        lda INTIM   ; Check the timer
        bne OSwait  ; Branch if its Not Equal to 0
        rts         ; ReTurn from Subroutine
    
    
        
;===============================================================================
; free space check before DigitGfx
;===============================================================================
        
 if (* & $FF)
    echo "------", [(>.+1)*256 - .]d, "bytes free before DigitGfx"
    align 256
  endif    
    
  
;===============================================================================
; Digit Graphics
;===============================================================================
        align 256
        
        
LineHeight                  
        .byte #$05,#$05,#$05,#$05,#$05,#$05,#$05,#$5,#$05,#$05,#$03,#$05,#$05,#$05,#$05,#$05,#$05,#$05,#$05,#$05,#$00;
		
ColorBackGround
	.byte #$76,#$48,#$76,#$48,#$76,#$48,#$14,#$14,#$16,#$18,#$1A,#$1C,#$1E,#$1E,#$76,#$48,#$76,#$48,#$76,#$48,#$00;
		
ColorForeGround
	.byte #$48,#$76,#$48,#$76,#$48,#$76,#$AE,#$AE,#$AC,#$A8,#$A6,#$A4,#$A0,#$A0,#$48,#$76,#$48,#$76,#$48,#$76,#$00;

PF0_left
	.byte #$50,#$50,#$50,#$50,#$50,#$50,#$00,#$C0,#$40,#$40,#$C0,#$40,#$40,#$00,#$50,#$50,#$50,#$50,#$50,#$50,#$00;
		
PF1_left
	.byte #$AA,#$AA,#$AA,#$AA,#$AA,#$AA,#$00,#$B3,#$AA,#$AA,#$AB,#$AA,#$B2,#$00,#$AA,#$AA,#$AA,#$AA,#$AA,#$AA,#$00;
		
PF2_left
	.byte #$55,#$55,#$55,#$55,#$55,#$55,#$00,#$74,#$55,#$55,#$74,#$55,#$55,#$00,#$55,#$55,#$55,#$55,#$55,#$55,#$00;
		
PF0_right
	.byte #$50,#$50,#$50,#$50,#$50,#$50,#$00,#$90,#$90,#$90,#$B0,#$F0,#$90,#$00,#$50,#$50,#$50,#$50,#$50,#$50,#$00;
		
PF1_right
	.byte #$AA,#$AA,#$AA,#$AA,#$AA,#$AA,#$00,#$70,#$50,#$50,#$50,#$50,#$70,#$00,#$AA,#$AA,#$AA,#$AA,#$AA,#$AA,#$00;
		
PF2_right
	.byte #$55,#$55,#$55,#$55,#$55,#$55,#$00,#$00,#$00,#$00,#$00,#$00,#$00,#$00,#$55,#$55,#$55,#$55,#$55,#$55,#$00;       
        
        
;===============================================================================
; free space check before End of Cartridge
;===============================================================================
        
 if (* & $FF)
    echo "------", [$FFFA - *]d, "bytes free before End of Cartridge"
    align 256
  endif        
        
;===============================================================================
; Define End of Cartridge
;===============================================================================
        ORG $FFFA        ; set address to 6507 Interrupt Vectors 
        .WORD InitSystem ; NMI
        .WORD InitSystem ; RESET
        .WORD InitSystem ; IRQ
        